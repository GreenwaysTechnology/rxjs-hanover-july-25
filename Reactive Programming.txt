											 Reactive Programming

       Reactive Programming is a programming paradigm, focused on asynchronous data streams and the propagation of change.

programming paradigm:

Every programming language based on programming paradigm (style/principle)

General Programming paradigms:
1.Object oriented
2.Procedural Oriented
3.Functional Style
4.Reactive Programming

JS is Object based, functional style programming language - Hybrid

Object oriented vs Object based:
........................................................
Object oriented principles:
..........................................
1.Abstraction
2.Encaspulation
3.Typing
4.Hierachy 
5.Modularity
*************************************************
6.Concurrency
7.Persistency

If any programming language implements first 5 principles 100%, those languages are called Object oriented Programming language.
if any language does not follow all five principles fully or five principles partially , those languages are called "Object Based" Programming language.

Functional Programming Principles:
..............................................................

1.Pure functions
2.Immuability
3.First class and Higher Order functions
4.Referential Transparency
5.Function Composition
6.Recursion over loops
7.Lazy Evaluation
8.Side Effects
etc....

if any programming languages follows all functional programming principles that language is called "Functional Programming language"
if not , that language is called "Functional Style programming language"
***********************************************************************************************************************************************************
										Asynchronous Programming
********************************************************************************************************************************************************

How to run multiple task concurrently , having single threaded environment?

Using single event loop thread, we can run multiple tasks.

Advantages:
1.Less Memory
2.Less CPU power
***********************************************************************************************************************************************************
										 data streams
*********************************************************************************************************************************************************

Stream:
    Flow of data
   	
***********************************************************************************************************************************************************
										Reactive programming is collection of many ideas

1.Design patterns
  -observer pattern 
 -iterator pattern
2.Functional Programming principles
  -pure functions 
  -immutability

 Reactive Programming = { Observer Design pattern, Iterator,  fp principles}

Push and Pull Programming:
................................................
observer pattern talks about how two programs communicate each other for transferring data.

In PULL  programming, consumer asks the data every time to the Producer - Sync way of communication - eg : iterators  -for loop

In PUSH Programming, producer sends the data to the consumer -Async way of communication - Reactive Programming

In modern days, we combine both - Push + Pull => Reactive Streams

Back Pressure:
   When producers sends data very fast to the consumers where consumers unable to process all data - This creates data loss.

How to solve this data loss?
        We have to enable back pressure feature

Reactive Programming = {Observer Pattern (push) ,Iterator Pattern(pull),Functional programming principles }
*********************************************************************************************************************************************************
									How to design reactive system
			   					    https://www.reactivemanifesto.org/
************************************************************************************************************************************************************

Is there any standards/ policies available to start reactive application

we want systems that are Responsive, Resilient, Elastic and Message Driven. We call these Reactive Systems.
Systems built as Reactive Systems are more flexible, loosely-coupled and scalable. This makes them easier to develop and amenable to change. 

Responsive
Resilient
Message Driven
Elastic

https://www.reactivemanifesto.org/
************************************************************************************************************************************************************
								   Reactive systems Implementation
***********************************************************************************************************************************************************

Reactive programming's foundational concepts were primarily developed by a team at Microsoft, led by computer scientist Erik Meijer, around 2011. 
They created the Reactive Extensions framework, later known as ReactiveX or Rx, for the .NET platform - First implementation
This framework was then adapted and implemented in various languages, including RxJava -Netflix
      - Java implementation
           -Rxjava
           -Project Reactor
           -Akka Streams
           -Red hat Mutiny 
 JavaScript implementation was available after java
    Rxjs
 
Async programming and implementation in java script:
1.callbacks
2.Promises
3.Promise with async ....await
4.reactive programming - Rxjs
************************************************************************************************************************************************************
									Rxjs core concepts
**********************************************************************************************************************************************************

Applications of Reactive programming:

1.Data Processing
  
 Data store - data sources - database
   In databases we can process data using SQL-Report
   In Application side, we can use language specific apis to process
	Java script has many apis
              array.filter, array.map ,array.find
 In Microsoft , inside .net languages , a feature was introduced called "LinQ"

LINQ (Language Integrated Query) in C# is a powerful feature that allows you to query and manipulate data from various sources using a consistent syntax, similar to SQL. It provides a unified way to work with data collections, databases, XML, and more, directly within your C# code. 

// Data source: a list of integers
List<int> numbers = new List<int> { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

// Query syntax:
// Select even numbers, order them, and take the first 3
var evenNumbersQuery = from num in numbers
                       where num % 2 == 0
                       orderby num
                       select num;

Reactive Programming = {LINQ + Observer Design pattern + Iterator Design Pattern+ async + etc....}
***********************************************************************************************************************************************************
										  RX JS implementation concepts
*********************************************************************************************************************************************************
1.Observable
    In General Observable represents Producer.
    In Programming Observable is "Data Type"
    Are lazy "Push"  Collection of multiple values
   Observable is implemented in js as "Object"

Push - Observable
Pull  - Iterator -for.. for..each

	             Producer                                                                                Consumer	

Pull          Passive: produces data when requested                                 Active: decides when data is requested

Push       Active : Produces data at is own pace                                     Passive: reacts to received data 

2.Observer
    In General Observer represents "Consumers/Listeners"
    In Programming Observer is "Data Type"
    Observer are just Objects with three callbacks
    Observers are simply set of Callbacks 
                - next
                -error
                -complete

3.Subscription
	In Rx, a subscription is the bridge between a data source (Observable/Publisher) and a consumer(Observer or Subscriber)
        Its what kicks off the data flow and manages how data is delivered
       It is also object
     Roles of subscription
	   1.Establish a connection
	   2.Controls data flow
            3.Manages life cycles - active or completed or errored, you can unsubscribe to stop receiving messages
           4.Handles clean up - teardown logic- like clearing intervals or releasing memory

4.Operators
        Are just apis.
        It is building block of rx
        Helps to create ,process data and streams
        we have a category of operators available

5.Schedulers
	 A scheduler controls when a subscription starts and when notifications are delivered.
   
6.Subjects 
	 It is special type of Observable that allows values to be Multicasted to many observers - One to Many - broadcasting
**********************************************************************************************************************************************************
											Project setup
***********************************************************************************************************************************************************

G:\hanover>mkdir rx-apps

G:\hanover>cd rx-apps
G:\hanover\rx-apps>npm init --yes
Wrote to G:\hanover\rx-apps\package.json:

{
  "name": "rx-apps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs"
}

G:\hanover\rx-apps>mkdir src

G:\hanover\rx-apps>npm install rxjs

How to test the code?

Using node.js
G:\hanover\rx-apps>node src/app.js
Hello rxjs

Using browser

rx-apps>index.html

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rxjs</title>
</head>
<body>
    <div>
        <h1>Rxjs App</h1>
        <script src="src/app.js"></script>
    </div>
</body>
</html>

in order to run, we need web server - live server
**********************************************************************************************************************************************************
											Getting started RXJS code
***********************************************************************************************************************************************************

Use Case: How to create Publisher and Subscriber , emit event.

There are three types of events

1.data event
      Which is triggered , when ever the data is emitted.
2.Error event
     which is triggered, when ever the error is emitted
3.Complete event
    which is triggered, when ever there is no more data - End

Publisher can be created using Observable Type or using operators (apis)

import { Observable } from "rxjs";


function main() {

    //Producer
    const observable = new Observable(subscriber => {
        //emit event - data
        subscriber.next('Hello')
        subscriber.next('Rxjs')
        //emit complete event
        subscriber.complete()
    })
    //subscriber
    observable.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got Error ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
*********************************************************************************************************************************************************
How to emit error?

import { Observable } from "rxjs";


function main() {

    //Producer
    const observable = new Observable(subscriber => {
        //emit event - data
        subscriber.next('Hello')
        subscriber.next('Rxjs')
        subscriber.error(new Error('Something went wrong!'))
        //emit complete event
        subscriber.complete()
    })
    //subscriber
    observable.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
***********************************************************************************************************************************************************

What if i emit data after error or complete?

After Complete:
import { Observable } from "rxjs";


function main() {

    //Producer
    const observable = new Observable(subscriber => {
        //emit event - data
        subscriber.next('Hello')
        subscriber.next('Rxjs')
        // subscriber.error(new Error('Something went wrong!'))
        //emit complete event
        subscriber.complete()
        subscriber.next('Hello Again')

    })
    //subscriber
    observable.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()

After Error:
import { Observable } from "rxjs";


function main() {

    //Producer
    const observable = new Observable(subscriber => {
        //emit event - data
        subscriber.next('Hello')
        subscriber.next('Rxjs')
        subscriber.error(new Error('Something went wrong!'))
        //emit complete event
        subscriber.next('Hello Again')

    })
    //subscriber
    observable.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
**********************************************************************************************************************************************************
We simulate:

1.Emitting user IDS with a delay (eg from an api)
2.Emit an error on specific condition
3.Complete if everything goes well.

import { Observable } from "rxjs";


function main() {

    //create usersId stream
    const userIdStream = new Observable(subscriber => {
        //mock usersid
        const userIds = [101, 102, 103, 104, 105]
        let index = 0
        const intervalId = setInterval(() => {
            if (index >= userIdStream.length) {
                //once all items are completed
                subscriber.complete()
                clearInterval(intervalId)
                return;
            }
            const id = userIds[index++];
            subscriber.next(`Fetched User ID : ${id}`)

            if (id === 103) {
                subscriber.error(new Error(`User Id ${id} causes an error`))
                clearInterval(intervalId)
            }

        }, 1000); //emit every 1 second

    })

    //subscriber
    userIdStream.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()

Task:
 const users = [{id:1,name:'x'},{id:2,name:'y']
***********************************************************************************************************************************************************

Use case: Emit Every user id  without error 

import { Observable } from "rxjs";


function main() {

    //create usersId stream
    const userIdStream = new Observable(subscriber => {
        //mock usersid
        const userIds = [101, 102, 103, 104, 105]
        let index = 0
        const intervalId = setInterval(() => {
            if (index >= userIds.length) {
                //once all items are completed
                subscriber.complete()
                clearInterval(intervalId)
                return;
            }
            const id = userIds[index++];
            subscriber.next(`Fetched User ID : ${id}`)

            // if (id === 103) {
            //     subscriber.error(new Error(`User Id ${id} causes an error`))
            //     clearInterval(intervalId)
            // }

        }, 1000); //emit every 1 second

    })

    //subscriber
    userIdStream.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
***********************************************************************************************************************************************************

How to run code inside browser using vite?

vite is build tool which takes care of packing js code and make it runnable inside browser

G:\hanover\rx-apps>npm i vite

package.json
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "vite"
  }

Running
npm run dev

> rx-apps@1.0.0 dev
> vite


  VITE v7.0.4  ready in 168 ms

  ➜  Local:   http://localhost:5173/
  ➜  Network: use --host to expose
  ➜  press h + enter to show help
**********************************************************************************************************************************************************

Use case: Improved version of the above code

1.Loading indicator ....Progress bar
2.Random delay and simulated latency
3.Random error injection with retry attempts

import { Observable } from "rxjs";

function getUserStream() {

    return new Observable(subscriber => {
        const userIds = [101, 102, 103, 104, 105]
        let index = 0
        const intervalId = setInterval(() => {
            if (index >= userIds.length) {
                //once all items are completed
                subscriber.complete()
                clearInterval(intervalId)
                return;
            }
            const id = userIds[index++];
            const latency = Math.floor(Math.random() * 1500) + 500 // 500 to 2000 ms
            console.log(`Loading...Delay ${latency}ms`)
            setTimeout(() => {
                //simulate error - 20%
                if (Math.random() < 0.2) {
                    const err = new Error(`Oops Something went wrong for ${id}`)
                    subscriber.error(err)
                    clearInterval(intervalId)
                } else {
                    subscriber.next(`Fetched User ID : ${id}`)
                }
            }, latency)


        }, 1000); //emit every 1 second
    })

}

function main() {
    getUserStream().subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}

main()
******************************************************************************************************************************************************
  											Operators
****************************************************************************************************************************************************
Operators are simply speaking which are functions /methods.

Types of Operators :
1.Creation Operators

class MathUtility{ 

   add(){
	return 0
   }
   //factory method
   getInstance(){
	return new MathUtility()
    }   

}
//constructor pattern
let utility = new MathUtilty()
utility.add()

//factory pattern
 let util = Math.getInstance()
util.add()
Math.getInstance().add()

In Rxjs:
Constructor Pattern
new Observable(function(){})

Factory Pattern : creational operator
 of ,from, fromEvent etc...
	
2.Pipeable Operators
   are kind of operators for data processing
   Any Pipeable operator is function that takes an Observable as its input and returns another Observable.
   It is pure function.
      ->When ever , we call operator, which returns "Observable" Type

Reactive Programming uses Functional Programming principles:
1.Pure functions
2.Immutability

Pure Functions:
    Pure functions are defined by two rules..
Rule A:
     if function receives input, the function returns the input without any mutation...
//pure function Rule A:

//pure function
function sayHello(message) {
    return message
}
console.log(sayHello('hello'))

//pure or not : No : Impure function
function doubleIt(value) {
    //side effects
    return value * 2
}
console.log(doubleIt(2))
************************************************************************************************************************************************************
Rule B:
    if function receives input, what if i want to change(mutate),We can apply rule b.
    if function receives input, and modify input , we should return new object every time, which is called immutability. 

//impure function: 
// function updateProfile(city, profile) {
//     profile.city = city
//     return profile
// }
//apply immutablity pattern: create new object every time
function updateProfile(city, profile) {

    // return {
    //     id: profile.id,
    //     name: profile.name,
    //     city: city
    // }
    // return Object.assign({}, profile, { city: city })

    return { ...profile, city: city }
}

function main() {
    const profile = {
        id: 1,
        name: 'Subrammanian Murugan',
        city: 'NewYork'
    }
    console.log('before update', profile)
    const result = updateProfile('London', profile)
    console.log('After update', result)
    console.log(profile === result ? 'Same Object' : 'Different Object')
}
main()
*********************************************************************************************************************************************
								Creational Operators
*********************************************************************************************************************************************
There are two types of Creational Operator

1.Creation Operators
2.Join Creation Operators

To Create an Observable from Various data sources .

1.Creation Operators:
1.1.create
1.2.of
1.3.from
1.4.fromEvent
1.5.interval
1.6.range
1.7.timer
1.8.generate 
1.9.empty
1.10.defer
1.11.ajax

1.1.create - creates an Observable from scratch .
import { Observable } from "rxjs"

function main() {
    const stream = Observable.create(observer => {
        observer.next(1)
        observer.next(2)
        observer.complete()
    })
    stream.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

1.2.of
   That allows you to create an Observable from a set of values.
   Values could be any thing like numbers, strings, objects

import { of } from "rxjs"

function main() {
    const stream = of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    stream.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
..............

Emitting Strings:
import { of } from "rxjs"

function streamFruits() {
    return of('apple', 'banana', 'organe', 'cherry')
}

function main() {
    streamFruits().subscribe({
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()

Emit Objects:
....................
import { of } from "rxjs"

function streamObjects() {
    return of({ id: 1, name: 'Subramanian' }, { id: 2, name: 'Murugan' }, { id: 3, name: 'Erik' })
}

function main() {
    streamObjects().subscribe({
        next: value => {
            console.log('Got',value)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
****************************************************************************************************************************************
									   from
				Creates an Observable from "array, promise ,Iterable, Or Observable like object"
*******************************************************************************************************************************************

Numeric Array:
import { from ,of} from "rxjs"

function streamArray() {
    const numList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    return from(numList)
}

function main() {
    streamArray().subscribe({
        next: value => {
            console.log('Got', value)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()

Array of Objects:
...........................
import { from ,of} from "rxjs"

import TODOS from "./mock-data/todos"

function streamArray() {
    return from(TODOS)
}

function main() {
    streamArray().subscribe({
        next: value => {
            console.log('Got', value)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
************************************************************************************************************************************************
								 How to Convert Promise into Observable
************************************************************************************************************************************************

Promise with Success:
import { from } from "rxjs"

function getPromise() {
    const promise = Promise.resolve('Hello')
    return from(promise)
}

function main() {
    getPromise().subscribe({
        next: value => {
            console.log('Got', value)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

}
main()

Promise with Error:
import { from } from "rxjs"

function getPromise() {
    const promise = Promise.reject('something went wrong!!')
    return from(promise)
}

function main() {
    getPromise().subscribe({
        next: value => {
            console.log('Got', value)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

}
main()
......................................................................

Promise with Success or Reject
import { from } from "rxjs"

function login(userName, password) {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login success')
    } else {
        return Promise.reject('Login Failed')
    }
}
function getPromise() {
    return from(login('admin', 'admin'))
 // return from(login('xxx','yyyy'))
}

function main() {
    getPromise().subscribe({
        next: value => {
            console.log('Got', value)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

}
main()

&&&&&&&&&&&&&&&&
Promise Constructors:

import { from } from "rxjs"

function login(userName, password) {
    return new Promise((resolve, reject) => {
        if (userName === 'admin' && password === 'admin') {
            resolve('login success')
        } else {
            reject('login failed')
        }
    })
}
function getPromise() {
    // return from(login('admin', 'admin'))
    return from(login('xxx','yyyy'))
}

function main() {
    getPromise().subscribe({
        next: value => {
            console.log('Got', value)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

}
main()
***************************************************************************************************************************************
Promise with Fetch 
import { from } from "rxjs"

function fetchPosts() {
    return fetch('https://jsonplaceholder.typicode.com/posts').then(res => res.json())
}
function getPromise() {
    return from(fetchPosts())
}

function main() {
    getPromise().subscribe({
        next: value => {
            console.log('Got', value)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

}
main()
*********************************************************************************************************************************************
										Promise vs Observable

Feature                                                Promise                                            Observable
1.Lazy vs Eager                           Eager(Executes immediately)                   Lazy(executes on subscribe)

import { of } from "rxjs"

function getPromise() {
    return Promise.resolve('hello')
}
function getObsverable() {
    return of(1, 2,)
}
function main() {
    //eager
    console.log(getPromise())
    //lazy
    console.log(getObsverable())
}
main()

2.Multiple values                                   Only One value at time                        Supports sequence of values(Stream)
							      (fire and forget)                                    (transfers data longer)


3.Cancelable                                        Not Cancelable                                     can be cancelled using "unsubscribe"


4.Operators                                         Basic chaining(then,catch)                    Rich set of operators for data processing

5.Multicasting                                       No built in support                                 Possible with help of operators

6.Error Handling                                .catch method only                                  Operators like CatchError and more

7.Reactive                                          No                                                            Yes
************************************************************************************************************************************************
										FromEvent
**********************************************************************************************************************************************
Converts any DOM events into Observable:
......................................................................

import { fromEvent } from "rxjs"

function main() {
    //attach document and convert dom events into observable
    const clickStream = fromEvent(document, 'click')
    //attach subscriber
    clickStream.subscribe({
        next: value => {
            console.log(`X ${value.clientX} Y ${value.clientY}`)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

}
main()

What it does?
1.Listens to a specific event on target(any DOM element,Node.js Event Emitter)
2.Emits each event as it occurs

Use case: Capture mouse move event:
...............................................................
import { fromEvent } from "rxjs"

function main() {
    //attach document and convert dom events into observable
    const clickStream = fromEvent(document, 'mousemove')
    //attach subscriber
    clickStream.subscribe({
        next: value => {
            console.log(`X ${value.clientX} Y ${value.clientY}`)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

React to Keyboard Input Event:
..................................................
import { fromEvent } from "rxjs"

function main() {
    const input = document.getElementById('searchBox')
    const inputStream = fromEvent(input, 'keyup')
    inputStream.subscribe({
        next: e => {
           console.log(`Key Pressed ${e.key}`)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										range

range is an creation operator that emits a sequence of values within specified range.

import { range } from "rxjs"


function main() {
    range(1, 100).subscribe({
        next: value => {
            console.log(`${value}`)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

}
main()

Using range , we can simulate pagination:
..................................................................
import { range } from "rxjs"


function main() {
    const pageSize = 10
    const totalItems = 1000
    range(0, totalItems / pageSize).subscribe({
        next: pageNumber => {
            console.log(`Loading page ${pageNumber + 1}`)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

}
main()
************************************************************************************************************************************************										Streams Types

1. Finite Stream
    There is logical end, that means, completed event will be emitted
2. Infinite Stream
	There is no logical end, that means, completed event will not be emitted
   interval - operator
      takes an timer as input, and emits value from 0...............until you cancel

import { interval } from "rxjs";


function main() {
    interval(1000).subscribe({
        next: value => {
            console.log(`Value ${value}`)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })


}
main()
**********************************************************************************************************************************************
How to stop interval?
import { interval } from "rxjs";


function main() {
    const stream = interval(1000).subscribe({
        next: value => {
            console.log(`Value ${value}`)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

    setTimeout(() => {
        console.log('going to stop')
        stream.unsubscribe()
    }, 10000)


}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									throwError

It creates an observable that immediately  throws error. It is useful for simulating errors or propagating them inside operator chains.

import { throwError } from "rxjs";


function main() {
    throwError(()=> new Error('Something went wrong')).subscribe({
        next: value => {
            console.log(`Value ${value}`)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

  }
main()
********************************************************************************************************************************************
									empty()

Creates an Observable that emits no items and immediately completes.

import { empty } from "rxjs";


function main() {
    empty().subscribe({
        next: value => {
            console.log(`Value ${value}`)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })

  


}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									timer
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

That creates an Observable  which emits a single value after a delay or
A stream of values starting after a delay and then a regular intervals.

timer(dueTime,period)

import { timer } from "rxjs";


function main() {
    timer(3000).subscribe({
        next: value => {
            console.log(`Fired after 3 seconds ${value}`)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })




}
main()
&&&&&&&&&&&&&&&

Start after delay , then repeat:
**********************************
import { timer } from "rxjs";


function main() {
    timer(3000,1000).subscribe({
        next: value => {
            console.log(`Fired ${value}`)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })




}
main()

									Difference between interval and timer

Features                                    timer                               interval
starts  after                              3 seconds                        immediately after 1st period
Emits                                        once by default              infinite stream
Use case                                  delay or timeout             repeated action
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										ajax
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
It is allows to perform HTTP requests(GET,POST ,etc) in a reactive way- similar to fetch , where fetch is promise based, which observable based.
import { ajax } from "rxjs/ajax";


function main() {
    ajax({
        url: 'https://jsonplaceholder.typicode.com/comments',
        method: 'GET',  
    }).subscribe({
        next: value => {
            console.log(value.response)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										iif
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
IIF IS A conditional creation function used to create an observable based on a runtime condition - similar to js if/else but reactive

iif(condtion,trueResult:obs,falseResult:obs)

import { EMPTY, iif, of } from "rxjs";


function main() {
    const showMessage = false
    iif(
        () => { return showMessage },
        of('Showing Message'),
        EMPTY
    ).subscribe({
        next: value => {
            console.log(value)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()

Toggle between observable:
.............................................
import { EMPTY, iif, of } from "rxjs";


function main() {
    const isLoggedIn = false
    iif(
        () => { return isLoggedIn },
        of('Welcome Back!'),
        of('Please Login')
    ).subscribe({
        next: value => {
            console.log(value)
        },
        error: err => {
            console.log(`Got Err:  ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									2.Join Creation Operators

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

These are Observables creation operators that also have join functionality - Emitting values of multiple source observables 

1.coimbineLatest
2.concat
3.forkJoin
4.merge
5.partition
6.race
7.zip

1.coimbineLatest:
...........................
It is combination operator that emits the latest values from multiple observables whenever any of them emits, but only after all have emitted at least once.

coimbineLastest([ob1,ob2,ob3,...])
1.Emits an array of the latest values from each observable

import { combineLatest, interval } from "rxjs"
function main() {
    const obs1 = interval(1000)
    const obs2 = interval(500)
    combineLatest([obs1, obs2]).subscribe(value => console.log(value))
}
main()
 &&&&&&&&&&&&&&&&&&&&&&&&&&&
Price calculator:

import { combineLatest, of } from "rxjs"
function main() {
    const price = of(1000)
    const qty = of(2)
    combineLatest([price, qty]).subscribe(value => console.log(value[0] * value[1]))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								concat
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

concat is combination  operator that "sequentially subscribes" to multiple observables and emits all their values in order - waiting for one to complete before moving to the next.

concat(ob1,ob2,ob3)

->It waits for each Observable to complete before subscribing to the next
->Emits values in strict order

import { concat, of } from "rxjs"
function main() {
    const first = of('A', 'B')
    const second = of('C', 'D')
    concat(first, second).subscribe(val => console.log(val))
}
main()

Sequential api call
import { concat, from, of } from "rxjs"
function main() {
    const api1 = from(fetch('https://jsonplaceholder.typicode.com/users/1').then(res => res.json()))
    const api2 = from(fetch('https://jsonplaceholder.typicode.com/users/2').then(res => res.json()))
    concat(api1, api2).subscribe(val => console.log(val))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											ZIP
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Zip is a combination operator that "combines multiple observables by waiting for all of them to emit one value " and then emitting those values a an array

zip(ob1,ob2,ob3)

1.Emits only when each observable has emitted
2.Pairs values by index; first  from each , then second from each etc...
3.Completes when the shortest observables completes.

Use Case: Both Observable has eq values
import { of, zip } from "rxjs"

function main() {
    const numbers = of(1, 2, 3, 4, 5)
    const characters = of('A', 'B', 'C', 'D', 'E')
    zip(numbers, characters).subscribe(val => console.log(val))
}
main()

Output:
 [1, 'A']
 [2, 'B']
 [3, 'C']
 [4, 'D']
 [5, 'E']

Task:
  User Id, his roles
 100- admin
 101 -guest
 103 -visitor
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
 interval with zip
...........................
import { interval, zip } from "rxjs"

function main() {
    const numbers1 = interval(1000)
    const numbers2 = interval(1000)
    zip(numbers1, numbers2).subscribe(val => console.log(val))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Projection:
.................
 take each observable value, show it as single item , instead of array

import { zip, of } from "rxjs"

function main() {
    const names = of('Subramanian', 'Erik', 'John', 'Ram', 'Geetha')
    const ages = of(45, 19, 23, 35, 32)

    zip(names, ages, (name, age) => { return `${name} is ${age} years old` })
        .subscribe(value => console.log(value))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									race
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

race is another combination operator that listens to multiple observables, and "only emits values from the one that emits first"
once the first observable emits, all others are unsubscribed 

race(ob1,ob2,ob3)

1.Winner: the Observable that emits first
2.Others, unsubscribed immediately 
3.Usefull for timeouts, fallbacks, and first-response wins

import { of, race } from "rxjs"

function main() {
    const first = of('first')
    const second = of('Second')
    race(first,second).subscribe(val=>console.log(`Winner : ${val}`))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

User vs System cancel:

import { fromEvent, of, race, timer } from "rxjs"

function main() {

    //keydown event binding
    const userCancel = fromEvent(document, 'keydown')
    const autoCancel = timer(5000) //system cancels
    race(userCancel, autoCancel).subscribe(val => {
        if (typeof val === 'number') {
            console.log('Auto cancelled')
        } else {
            console.log('Cancelled by user')
        }
    })

}
main()

Test:
Just press Enter/Space key
or
Wait for 5ms 
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											merge
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

		merge allows "Multiple observables to emit values concurrently into a single observable"

merge(obs1,obs2,obs3)

1.Emit all values from all input observables
2.Emits as soon as any observable emits
3.Does not wait for completion like concat
4.Usefull for combining independent , parallel streams

import { merge, of } from "rxjs"

function main() {

    const characters = of('A', 'B')
    const numbers = of(1, 2, 3)
    merge(characters,numbers).subscribe(val=>console.log(val))

}
main()

Merge User Events:
...................................

import { from, fromEvent, merge, of } from "rxjs"

function main() {

    const clicks = fromEvent(document, 'click')
    const keypress = fromEvent(document, 'keydown')
    merge(clicks, keypress).subscribe(event => console.log(`User Action ${event.type}`))

}
main()

Merge api calls:
............................
import { merge,from } from "rxjs"

function main() {

    const url1 = "https://jsonplaceholder.typicode.com/users/1"
    const url2 = "https://jsonplaceholder.typicode.com/users/2"
    const api1 = from(fetch(url1).then(res => res.json()))
    const api2 = from(fetch(url2).then(res => res.json()))
    merge(api1, api2).subscribe(user => console.log(`User Name ${user.name}`))

}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
							   merge vs concat vs coimbineLatest

Operator                        Emits Immediately                    Waits for All?                     Order Guaranteed?
-----------------------------------------------------------------------------------------------------------------------------------
merge                            Yes                                             No                                       No
concat                            No(sequential)                         Yes                                       Yes
coimbineLatest             No(after all emit once)               Yes                                     No(interleaved)
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&