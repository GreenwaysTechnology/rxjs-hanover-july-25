											 Reactive Programming

       Reactive Programming is a programming paradigm, focused on asynchronous data streams and the propagation of change.

programming paradigm:

Every programming language based on programming paradigm (style/principle)

General Programming paradigms:
1.Object oriented
2.Procedural Oriented
3.Functional Style
4.Reactive Programming

JS is Object based, functional style programming language - Hybrid

Object oriented vs Object based:
........................................................
Object oriented principles:
..........................................
1.Abstraction
2.Encaspulation
3.Typing
4.Hierachy 
5.Modularity
*************************************************
6.Concurrency
7.Persistency

If any programming language implements first 5 principles 100%, those languages are called Object oriented Programming language.
if any language does not follow all five principles fully or five principles partially , those languages are called "Object Based" Programming language.

Functional Programming Principles:
..............................................................

1.Pure functions
2.Immuability
3.First class and Higher Order functions
4.Referential Transparency
5.Function Composition
6.Recursion over loops
7.Lazy Evaluation
8.Side Effects
etc....

if any programming languages follows all functional programming principles that language is called "Functional Programming language"
if not , that language is called "Functional Style programming language"
***********************************************************************************************************************************************************
										Asynchronous Programming
********************************************************************************************************************************************************

How to run multiple task concurrently , having single threaded environment?

Using single event loop thread, we can run multiple tasks.

Advantages:
1.Less Memory
2.Less CPU power
***********************************************************************************************************************************************************
										 data streams
*********************************************************************************************************************************************************

Stream:
    Flow of data
   	
***********************************************************************************************************************************************************
										Reactive programming is collection of many ideas

1.Design patterns
  -observer pattern 
 -iterator pattern
2.Functional Programming principles
  -pure functions 
  -immutability

 Reactive Programming = { Observer Design pattern, Iterator,  fp principles}

Push and Pull Programming:
................................................
observer pattern talks about how two programs communicate each other for transferring data.

In PULL  programming, consumer asks the data every time to the Producer - Sync way of communication - eg : iterators  -for loop

In PUSH Programming, producer sends the data to the consumer -Async way of communication - Reactive Programming

In modern days, we combine both - Push + Pull => Reactive Streams

Back Pressure:
   When producers sends data very fast to the consumers where consumers unable to process all data - This creates data loss.

How to solve this data loss?
        We have to enable back pressure feature

Reactive Programming = {Observer Pattern (push) ,Iterator Pattern(pull),Functional programming principles }
*********************************************************************************************************************************************************
									How to design reactive system
			   					    https://www.reactivemanifesto.org/
************************************************************************************************************************************************************

Is there any standards/ policies available to start reactive application

we want systems that are Responsive, Resilient, Elastic and Message Driven. We call these Reactive Systems.
Systems built as Reactive Systems are more flexible, loosely-coupled and scalable. This makes them easier to develop and amenable to change. 

Responsive
Resilient
Message Driven
Elastic

https://www.reactivemanifesto.org/
************************************************************************************************************************************************************
								   Reactive systems Implementation
***********************************************************************************************************************************************************

Reactive programming's foundational concepts were primarily developed by a team at Microsoft, led by computer scientist Erik Meijer, around 2011. 
They created the Reactive Extensions framework, later known as ReactiveX or Rx, for the .NET platform - First implementation
This framework was then adapted and implemented in various languages, including RxJava -Netflix
      - Java implementation
           -Rxjava
           -Project Reactor
           -Akka Streams
           -Red hat Mutiny 
 JavaScript implementation was available after java
    Rxjs
 
Async programming and implementation in java script:
1.callbacks
2.Promises
3.Promise with async ....await
4.reactive programming - Rxjs
************************************************************************************************************************************************************
									Rxjs core concepts
**********************************************************************************************************************************************************

Applications of Reactive programming:

1.Data Processing
  
 Data store - data sources - database
   In databases we can process data using SQL-Report
   In Application side, we can use language specific apis to process
	Java script has many apis
              array.filter, array.map ,array.find
 In Microsoft , inside .net languages , a feature was introduced called "LinQ"

LINQ (Language Integrated Query) in C# is a powerful feature that allows you to query and manipulate data from various sources using a consistent syntax, similar to SQL. It provides a unified way to work with data collections, databases, XML, and more, directly within your C# code. 

// Data source: a list of integers
List<int> numbers = new List<int> { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

// Query syntax:
// Select even numbers, order them, and take the first 3
var evenNumbersQuery = from num in numbers
                       where num % 2 == 0
                       orderby num
                       select num;

Reactive Programming = {LINQ + Observer Design pattern + Iterator Design Pattern+ async + etc....}
***********************************************************************************************************************************************************
										  RX JS implementation concepts
*********************************************************************************************************************************************************
1.Observable
    In General Observable represents Producer.
    In Programming Observable is "Data Type"
    Are lazy "Push"  Collection of multiple values
   Observable is implemented in js as "Object"

Push - Observable
Pull  - Iterator -for.. for..each

	             Producer                                                                                Consumer	

Pull          Passive: produces data when requested                                 Active: decides when data is requested

Push       Active : Produces data at is own pace                                     Passive: reacts to received data 

2.Observer
    In General Observer represents "Consumers/Listeners"
    In Programming Observer is "Data Type"
    Observer are just Objects with three callbacks
    Observers are simply set of Callbacks 
                - next
                -error
                -complete

3.Subscription
	In Rx, a subscription is the bridge between a data source (Observable/Publisher) and a consumer(Observer or Subscriber)
        Its what kicks off the data flow and manages how data is delivered
       It is also object
     Roles of subscription
	   1.Establish a connection
	   2.Controls data flow
            3.Manages life cycles - active or completed or errored, you can unsubscribe to stop receiving messages
           4.Handles clean up - teardown logic- like clearing intervals or releasing memory

4.Operators
        Are just apis.
        It is building block of rx
        Helps to create ,process data and streams
        we have a category of operators available

5.Schedulers
	 A scheduler controls when a subscription starts and when notifications are delivered.
   
6.Subjects 
	 It is special type of Observable that allows values to be Multicasted to many observers - One to Many - broadcasting
**********************************************************************************************************************************************************
											Project setup
***********************************************************************************************************************************************************

G:\hanover>mkdir rx-apps

G:\hanover>cd rx-apps
G:\hanover\rx-apps>npm init --yes
Wrote to G:\hanover\rx-apps\package.json:

{
  "name": "rx-apps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs"
}

G:\hanover\rx-apps>mkdir src

G:\hanover\rx-apps>npm install rxjs

How to test the code?

Using node.js
G:\hanover\rx-apps>node src/app.js
Hello rxjs

Using browser

rx-apps>index.html

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rxjs</title>
</head>
<body>
    <div>
        <h1>Rxjs App</h1>
        <script src="src/app.js"></script>
    </div>
</body>
</html>

in order to run, we need web server - live server
**********************************************************************************************************************************************************
											Getting started RXJS code
***********************************************************************************************************************************************************

Use Case: How to create Publisher and Subscriber , emit event.

There are three types of events

1.data event
      Which is triggered , when ever the data is emitted.
2.Error event
     which is triggered, when ever the error is emitted
3.Complete event
    which is triggered, when ever there is no more data - End

Publisher can be created using Observable Type or using operators (apis)

import { Observable } from "rxjs";


function main() {

    //Producer
    const observable = new Observable(subscriber => {
        //emit event - data
        subscriber.next('Hello')
        subscriber.next('Rxjs')
        //emit complete event
        subscriber.complete()
    })
    //subscriber
    observable.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got Error ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
*********************************************************************************************************************************************************
How to emit error?

import { Observable } from "rxjs";


function main() {

    //Producer
    const observable = new Observable(subscriber => {
        //emit event - data
        subscriber.next('Hello')
        subscriber.next('Rxjs')
        subscriber.error(new Error('Something went wrong!'))
        //emit complete event
        subscriber.complete()
    })
    //subscriber
    observable.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
***********************************************************************************************************************************************************

What if i emit data after error or complete?

After Complete:
import { Observable } from "rxjs";


function main() {

    //Producer
    const observable = new Observable(subscriber => {
        //emit event - data
        subscriber.next('Hello')
        subscriber.next('Rxjs')
        // subscriber.error(new Error('Something went wrong!'))
        //emit complete event
        subscriber.complete()
        subscriber.next('Hello Again')

    })
    //subscriber
    observable.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()

After Error:
import { Observable } from "rxjs";


function main() {

    //Producer
    const observable = new Observable(subscriber => {
        //emit event - data
        subscriber.next('Hello')
        subscriber.next('Rxjs')
        subscriber.error(new Error('Something went wrong!'))
        //emit complete event
        subscriber.next('Hello Again')

    })
    //subscriber
    observable.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
**********************************************************************************************************************************************************
We simulate:

1.Emitting user IDS with a delay (eg from an api)
2.Emit an error on specific condition
3.Complete if everything goes well.

import { Observable } from "rxjs";


function main() {

    //create usersId stream
    const userIdStream = new Observable(subscriber => {
        //mock usersid
        const userIds = [101, 102, 103, 104, 105]
        let index = 0
        const intervalId = setInterval(() => {
            if (index >= userIdStream.length) {
                //once all items are completed
                subscriber.complete()
                clearInterval(intervalId)
                return;
            }
            const id = userIds[index++];
            subscriber.next(`Fetched User ID : ${id}`)

            if (id === 103) {
                subscriber.error(new Error(`User Id ${id} causes an error`))
                clearInterval(intervalId)
            }

        }, 1000); //emit every 1 second

    })

    //subscriber
    userIdStream.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()

Task:
 const users = [{id:1,name:'x'},{id:2,name:'y']
***********************************************************************************************************************************************************

Use case: Emit Every user id  without error 

import { Observable } from "rxjs";


function main() {

    //create usersId stream
    const userIdStream = new Observable(subscriber => {
        //mock usersid
        const userIds = [101, 102, 103, 104, 105]
        let index = 0
        const intervalId = setInterval(() => {
            if (index >= userIds.length) {
                //once all items are completed
                subscriber.complete()
                clearInterval(intervalId)
                return;
            }
            const id = userIds[index++];
            subscriber.next(`Fetched User ID : ${id}`)

            // if (id === 103) {
            //     subscriber.error(new Error(`User Id ${id} causes an error`))
            //     clearInterval(intervalId)
            // }

        }, 1000); //emit every 1 second

    })

    //subscriber
    userIdStream.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
***********************************************************************************************************************************************************

How to run code inside browser using vite?

vite is build tool which takes care of packing js code and make it runnable inside browser

G:\hanover\rx-apps>npm i vite

package.json
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "vite"
  }

Running
npm run dev

> rx-apps@1.0.0 dev
> vite


  VITE v7.0.4  ready in 168 ms

  ➜  Local:   http://localhost:5173/
  ➜  Network: use --host to expose
  ➜  press h + enter to show help
**********************************************************************************************************************************************************

Use case: Improved version of the above code

1.Loading indicator ....Progress bar
2.Random delay and simulated latency
3.Random error injection with retry attempts

import { Observable } from "rxjs";

function getUserStream() {

    return new Observable(subscriber => {
        const userIds = [101, 102, 103, 104, 105]
        let index = 0
        const intervalId = setInterval(() => {
            if (index >= userIds.length) {
                //once all items are completed
                subscriber.complete()
                clearInterval(intervalId)
                return;
            }
            const id = userIds[index++];
            const latency = Math.floor(Math.random() * 1500) + 500 // 500 to 2000 ms
            console.log(`Loading...Delay ${latency}ms`)
            setTimeout(() => {
                //simulate error - 20%
                if (Math.random() < 0.2) {
                    const err = new Error(`Oops Something went wrong for ${id}`)
                    subscriber.error(err)
                    clearInterval(intervalId)
                } else {
                    subscriber.next(`Fetched User ID : ${id}`)
                }
            }, latency)


        }, 1000); //emit every 1 second
    })

}

function main() {
    getUserStream().subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}

main()
******************************************************************************************************************************************************
  											Operators
****************************************************************************************************************************************************
Operators are simply speaking which are functions /methods.

Types of Operators :
1.Creation Operators

class MathUtility{ 

   add(){
	return 0
   }
   //factory method
   getInstance(){
	return new MathUtility()
    }   

}
//constructor pattern
let utility = new MathUtilty()
utility.add()

//factory pattern
 let util = Math.getInstance()
util.add()
Math.getInstance().add()

In Rxjs:
Constructor Pattern
new Observable(function(){})

Factory Pattern : creational operator
 of ,from, fromEvent etc...
	
2.Pipeable Operators
   are kind of operators for data processing
   Any Pipeable operator is function that takes an Observable as its input and returns another Observable.
   It is pure function.
      ->When ever , we call operator, which returns "Observable" Type

Reactive Programming uses Functional Programming principles:
1.Pure functions
2.Immutability

Pure Functions:
    Pure functions are defined by two rules..
Rule A:
     if function receives input, the function returns the input without any mutation...
//pure function Rule A:

//pure function
function sayHello(message) {
    return message
}
console.log(sayHello('hello'))

//pure or not : No : Impure function
function doubleIt(value) {
    //side effects
    return value * 2
}
console.log(doubleIt(2))
************************************************************************************************************************************************************
Rule B:
    if function receives input, what if i want to change(mutate),We can apply rule b.
    if function receives input, and modify input , we should return new object every time, which is called immutability. 

//impure function: 
// function updateProfile(city, profile) {
//     profile.city = city
//     return profile
// }
//apply immutablity pattern: create new object every time
function updateProfile(city, profile) {

    // return {
    //     id: profile.id,
    //     name: profile.name,
    //     city: city
    // }
    // return Object.assign({}, profile, { city: city })

    return { ...profile, city: city }
}

function main() {
    const profile = {
        id: 1,
        name: 'Subrammanian Murugan',
        city: 'NewYork'
    }
    console.log('before update', profile)
    const result = updateProfile('London', profile)
    console.log('After update', result)
    console.log(profile === result ? 'Same Object' : 'Different Object')
}
main()
*********************************************************************************************************************************************
								Creational Operators
*********************************************************************************************************************************************
There are two types of Creational Operator

1.Creation Operators
2.Join Creation Operators

To Create an Observable from Various data sources .

1.Creation Operators:
1.1.create
1.2.of
1.3.from
1.4.fromEvent
1.5.interval
1.6.range
1.7.timer
1.8.generate 
1.9.empty
1.10.defer
1.11.ajax

1.1.create - creates an Observable from scratch .
import { Observable } from "rxjs"

function main() {
    const stream = Observable.create(observer => {
        observer.next(1)
        observer.next(2)
        observer.complete()
    })
    stream.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

1.2.of
   That allows you to create an Observable from a set of values.
   Values could be any thing like numbers, strings, objects

import { of } from "rxjs"

function main() {
    const stream = of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    stream.subscribe({
        //listeners
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
..............

Emitting Strings:
import { of } from "rxjs"

function streamFruits() {
    return of('apple', 'banana', 'organe', 'cherry')
}

function main() {
    streamFruits().subscribe({
        next: value => {
            console.log(`Got ${value}`)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()

Emit Objects:
....................
import { of } from "rxjs"

function streamObjects() {
    return of({ id: 1, name: 'Subramanian' }, { id: 2, name: 'Murugan' }, { id: 3, name: 'Erik' })
}

function main() {
    streamObjects().subscribe({
        next: value => {
            console.log('Got',value)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
****************************************************************************************************************************************
									   from
				Creates an Observable from "array, promise ,Iterable, Or Observable like object"
*******************************************************************************************************************************************

Numeric Array:
import { from ,of} from "rxjs"

function streamArray() {
    const numList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    return from(numList)
}

function main() {
    streamArray().subscribe({
        next: value => {
            console.log('Got', value)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()

Array of Objects:
...........................
import { from ,of} from "rxjs"

import TODOS from "./mock-data/todos"

function streamArray() {
    return from(TODOS)
}

function main() {
    streamArray().subscribe({
        next: value => {
            console.log('Got', value)
        },
        error: err => {
            console.log(`Got ${err}`)
        },
        complete: () => {
            console.log('Completed')
        }
    })
}
main()
************************************************************************************************************************************************
								 How to Convert Promise into Observable
************************************************************************************************************************************************











