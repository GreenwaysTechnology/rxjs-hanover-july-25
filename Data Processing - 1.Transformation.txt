									   Data Processing - 1.Transformation Operators


In Reactive programming , the data is streamed from one place(Observable)  into another Place called (Subscriber), while streaming, we can process the data using operators.

In order to process data , we have many data processing Operators:

1.Transformation Operators
2.Filtering Operator 
3.Join Operators
4.Error Handling operators
5.Mathematical operators
6.Conditional and Boolean Operators
7.Multicasting Operators
8.Utility Operators

1.Transformation Operators

1.1.map
1.2.mapTo
1.3.scan
1.4.window
1.5.groupBy
etc...

Transform the emitted values from an observable into a new Format or structure.

Data Processing

Create Observable:
   of().pipe(
     data processing operator,dataoperators
   ).subscribe(value=>console.log(value)
********************************************************************************************************************************************************
map:
   Used to transform each value emited by an observable into new value using projection function

obs.pipe(map,x,y).subscribe()

import { map, of } from 'rxjs'
function main() {
    of(1, 2, 3, 4, 5)
        .pipe(
            map(x => x * 2)
        )
        .subscribe(val => console.log(val))
}
main()

Transform Form Input Text into uppercase:
......................................................................
import { fromEvent, map, of } from 'rxjs'
function main() {
    fromEvent(document.getElementById('username'), 'input')
        .pipe(
            map(e => e.target.value.toUpperCase())
        ).subscribe(value => console.log(value))
}
main()

Calculate Values:
.............................
import { fromEvent, map, of } from 'rxjs'
function main() {
    const price = of(100)
    price.pipe(
        map(price => price * 1.18), //Add 18%
        map(totalprice => totalprice * 5.0) //Add 5%
    ).subscribe(v => console.log(v))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									mapTo

Replace emissions with a Fixed value
The mapTo operator in rx js similar to map- instead of transforming each value; it replaces every emitted value with a constant value

->Takes a single Arg
->Use when you dont care about the original value, only the fact that something happened like event or status

import { mapTo, of } from "rxjs"
function main() {
    of(1, 2, 3).pipe(
        mapTo('Clicked')
    ).subscribe(val => console.log(val))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
						  buffer,bufferCount,bufferTime,bufferToggle
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Collect Emissions until notified

The buffer operator in Rxjs collects values from the source observable until another observable emits and then it emits those buffered values as an array.

buffer operator is a powerful tool for batching emitted values from a source observable until a notifier observable emits. Think of it as a â€œcollect and releaseâ€ mechanism.

 How It Works
- It collects values from the source observable into an array.
- When the notifier observable emits, it flushes the array downstream.
- Then it starts buffering again until the next notifier emission



import { buffer, from, fromEvent, interval, take } from "rxjs"

function main() {
    const clicks = fromEvent(document, 'click')
    const intervals = interval(1000)
    intervals.pipe(buffer(clicks)).subscribe(values => console.log('Buffered', values))
}
main()
- interval$ emits a value every second.
- clicks$ acts as the notifier.
- Every time you click, it emits the buffered array of interval values since the last click

**********************************************************************************************************************************************

Capture KeyPresses Until EnterKey:
import { buffer, filter, from, fromEvent, interval, take } from "rxjs"

function main() {
    const keydowns = fromEvent(document, 'keydown')
    const enterKey = keydowns.pipe(
        filter(e => e.key === 'Enter')
    )
    enterKey.pipe(
        buffer(enterKey)
    ).subscribe(v => console.log(v))
}
main()

ðŸ” Use Cases
- Batching user interactions (e.g., clicks, keystrokes).
- Reducing expensive operations by grouping events.
- Custom throttling or debouncing strategies.

ðŸ§© Related Operators
| Operator | Behavior | 
| bufferCount | Emits buffer when a set number of values are collected. | 
| bufferTime | Emits buffer after a specified time interval. | 
| bufferToggle | Opens/closes buffers based on opening/closing observables. | 
| bufferWhen | Uses a function to determine when to close the buffer. | 
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									bufferCount
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

It groups elements based on buffer size
collects values until the buffersize is reached
emits the buffered array downstream

Use case:
1.batch processing: send data in chunks to reduce load
2.UI event tracking : Capture last N keystorkes or clicks
3.Rate limiting : Control how often operations are triggered.

import { buffer, bufferCount, from, fromEvent, interval, take } from "rxjs"

function main() {
    const intervals = interval(1000)
    intervals.pipe(
        bufferCount(5)
    ).subscribe(values => console.log('Buffered', values))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										 bufferTime
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

What it does?
1.Bufferes values for a specified duration
2.Emits the buffered array after each time span
import { buffer, bufferCount, bufferTime, from, fromEvent, interval, take } from "rxjs"

function main() {
    const intervals = interval(1000)
    intervals.pipe(
        bufferTime(2000) //emit every 2sec
    ).subscribe(values => console.log('Buffered', values))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									bufferToggle
*******************************************************************************************************************************************************

It is dynamic operator  that lets you open and close buffers based on signals  from two observables - one to start collecting values, and one to stop

What it does?
 starts buffering when the openings observables emits
Close the buffer when the closing selector observable
Emits the collected array and starts fresh one.

import { bufferToggle, fromEvent, interval } from "rxjs"

function main() {
    const clicks = fromEvent(document, 'click')
    const openings = interval(5000)//start buffering every 5 secs
    const closingSelector = () => interval(2000) // close the buffer after 2 secs
    const buffer = clicks.pipe(
        bufferToggle(openings, closingSelector)
    )
    buffer.subscribe(value => console.log(value))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									bufferWhen
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

->starts collecting values from the source observable
->calls the closing selector function, which returns observable 
->when that observable emits, the buffer is flushed and new one starts
import { bufferWhen, interval } from "rxjs"

function main() {
    const source = interval(500) //emits every 500secs
    const buffered = source.pipe(
        bufferWhen(() => interval(3000)) //close the buffer every 3 secs
    )
    buffered.subscribe(values => console.log(values))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								window,windowCount,windowTime,windowToggle,windowWhen
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

It is like buffer, but instead of collecting values into Arrays, it emits "Observable"- each representing a "window" of values from the source.

What it does?
->It Splits the source observable into multiple inner observables(windows)
->Each window collects values until a "WindowBoundaries" observable emits
->When that happens, the current window completes and a new one starts

import { fromEvent, interval,take,window,map, mergeAll } from "rxjs"

function main() {
    const clicks = fromEvent(document, 'click')
    const boundaries = interval(5000) //emits every 5 secs

    const windowed = clicks.pipe(
        window(boundaries), // create new window every 5 secs
        map(win=>win.pipe(take(2))),//take at most 2 clicks per window
        mergeAll() //flatten the inner observables
    )
    windowed.subscribe(val => console.log(val.x))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								windowCount
*****************************************************************************************************************************************************
Emits  a new inner observable(window) every startWindowEvery emissions
Each window collects ut to windowsize values
unlike bufferCount,it emits observables, not arrays

import { interval, mergeAll, windowCount } from "rxjs"

function main() {
    const source = interval(1000)
    const windowed = source.pipe(
        windowCount(5), // each window gets 3 values(obsverable)
        mergeAll()
    )
    windowed.subscribe(value => console.log(value))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								windowToggle
********************************************************************************************************************************************************

It is a transformation operator that lets you open and close "windows of emissions" based on two observables- one to start and one to stop, it is like bufferToggle, but instead of emitting arrays, it emits inner observables.

import { fromEvent, interval, mergeAll, windowToggle} from "rxjs"

function main() {
    const source = fromEvent(document,'click') 
    const openings = interval(5000) //open a window every 5 secs
    const closingSelector = ()=>interval(2000) //close the window after 2 secs

    const windowed = source.pipe(
        windowToggle(openings,closingSelector), // each window gets 3 values(obsverable)
        mergeAll()
    )
    windowed.subscribe(value => console.log(value))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								windowWhen
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Each window is an observable, that closes based on a custom condition.

import { fromEvent, interval, mergeAll, windowToggle, windowWhen} from "rxjs"

function main() {
    const source = interval(1000)

    const windowed = source.pipe(
        windowWhen(()=>interval(5000)), //close the window every 5 secs
        mergeAll()
    )
    windowed.subscribe(value => console.log(value))
}
main()
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									scan, switch, switchScan
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&